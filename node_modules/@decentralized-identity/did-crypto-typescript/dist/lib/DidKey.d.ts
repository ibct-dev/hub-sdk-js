/// <reference types="node" />
import { KeyExport } from './KeyExport';
import { KeyOperation } from './KeyOperation';
import { KeyType } from './KeyType';
import { KeyUse } from './KeyUse';
/**
 * Class to model a key
 */
export default class DidKey {
    private _keyType;
    private _keyUse;
    private _algorithm;
    private _crypto;
    private _exportable;
    private _rawKey;
    private _jwkKeys;
    private _didMasterKeys;
    private _didPairwiseKeys;
    /**
     * Create an instance of DidKey.
     * @param crypto The crypto object.
     * @param algorithm Intended algorithm to use for the key.
     * @param key The key.
     * @param exportable True if the key is exportable.
     */
    constructor(crypto: any, algorithm: any, key?: any, exportable?: boolean);
    /**
     * Gets the intended algorithm to use for the key.
     */
    readonly algorithm: any;
    /**
     * Gets the exportable property of the key indicating whether the app can extract the key.
     */
    readonly exportable: boolean;
    /**
     * Gets the key type.
     */
    readonly keyType: KeyType;
    /**
     * Gets the key use.
     */
    readonly keyUse: KeyUse;
    /**
     * Gets the key in jwk format.
     */
    getJwkKey(keyExport: KeyExport): Promise<any>;
    /**
     * Sign the data with the current key
     * @param data  Data to be signed with the current key
     */
    sign(data: Buffer): Promise<ArrayBuffer>;
    /**
     * Sign the data with the current key
     * @param data  The data signed with the current key
     * @param signature  The signature on the data
     */
    verify(data: Buffer, signature: ArrayBuffer): Promise<boolean>;
    /**
     * Generate a pairwise key
     * @param seed  The master seed for generating pairwise keys
     * @param did  The owner DID
     * @param peerId  The representation of the peer
     */
    generatePairwise(seed: Buffer, did: string, peerId: string): Promise<DidKey>;
    /**
     * Normalize the algorithm so it can be used by underlying crypto.
     * @param algorithm Algorithm to be normalized
     */
    static normalizeAlgorithm(algorithm: any): any;
    /**
     * Normalize the jwk so it can be used by underlying crypto.
     * @param jwk Json web key to be normalized
     */
    static normalizeJwk(jwk: any): any;
    /**
     * Returns an array of key operations.
     */
    getKeyOperations(keyUse: KeyUse, keyExport: KeyExport): Array<KeyOperation>;
    /**
     * Returns a boolean indicating whether the key
     * type of the instance is either KeyType.EC or
     * KeyType.RSA.
     */
    private readonly isKeyPair;
    private mapDidPairwiseKeys;
    /**
     * Generate a pairwise did master key.
     * @param seed  The master seed for generating pairwise keys
     * @param did  The owner DID
     * @param peerId  The representation of the peer
     */
    private generateDidMasterKey;
    private getKeyIdentifier;
    private getJwkKeyFromCache;
    private cacheJwkKey;
    private getOrGenerateKey;
    private setFromRawKey;
    private generateOctKey;
    private generateKeyPair;
    private keyObjectToJwk;
    /**
     * Map the W3C algorithm to JWA format
     * @param alg Ma
     */
    private getJoseAlg;
}
