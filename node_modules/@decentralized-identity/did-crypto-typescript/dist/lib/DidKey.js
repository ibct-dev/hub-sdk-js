"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const base64url_1 = __importDefault(require("base64url"));
const KeyExport_1 = require("./KeyExport");
const KeyOperation_1 = require("./KeyOperation");
const KeyType_1 = __importStar(require("./KeyType"));
const KeyUse_1 = __importStar(require("./KeyUse"));
const MasterKey_1 = __importDefault(require("./MasterKey"));
const PairwiseKey_1 = __importDefault(require("./PairwiseKey"));
const clone = require('clone');
// Name curves
const CURVE_P256K = 'P-256K';
const CURVE_K256 = 'K-256';
const TEMPORARY_KID = '#key1';
/**
 * Class to model a key
 */
class DidKey {
    /**
     * Create an instance of DidKey.
     * @param crypto The crypto object.
     * @param algorithm Intended algorithm to use for the key.
     * @param key The key.
     * @param exportable True if the key is exportable.
     */
    constructor(crypto, algorithm, key = undefined, exportable = true) {
        // Store for jwk keys in different formats. This is the format returned by exportKey
        this._jwkKeys = new Map();
        // Set of master keys
        this._didMasterKeys = [];
        // Set of pairwise keys
        this._didPairwiseKeys = new Map();
        this._crypto = crypto;
        // Check algorithm
        if (!algorithm.name) {
            throw new Error('Missing property name in algorithm');
        }
        this._keyUse = KeyUse_1.default.create(algorithm);
        this._keyType = KeyType_1.default.create(algorithm);
        this._exportable = exportable;
        this._algorithm = algorithm;
        // Set the raw key. Can be null if the key needs to be generated
        this._rawKey = key;
    }
    /**
     * Gets the intended algorithm to use for the key.
     */
    get algorithm() {
        return this._algorithm;
    }
    /**
     * Gets the exportable property of the key indicating whether the app can extract the key.
     */
    get exportable() {
        return this._exportable;
    }
    /**
     * Gets the key type.
     */
    get keyType() {
        return this._keyType;
    }
    /**
     * Gets the key use.
     */
    get keyUse() {
        return this._keyUse;
    }
    /**
     * Gets the key in jwk format.
     */
    async getJwkKey(keyExport) {
        // check if key is already cached
        const keyId = this.getKeyIdentifier(this.keyType, this.keyUse, keyExport);
        let jwkKey = this.getJwkKeyFromCache(keyId);
        if (jwkKey) {
            // Return the key if it already exists
            return jwkKey;
        }
        // Get the key or generate the key if needed
        jwkKey = await this.getOrGenerateKey(keyExport);
        // Normalize curve
        if (jwkKey.crv) {
            jwkKey.crv = this._algorithm.namedCurve;
        }
        // Save jwk format
        this.cacheJwkKey(keyId, jwkKey);
        // Check to save public key
        if (this.isKeyPair && keyExport === KeyExport_1.KeyExport.Private) {
            // Save only public key
            const jwkPublic = {};
            jwkPublic.kty = jwkKey.kty;
            if (jwkKey.use) {
                jwkPublic.use = jwkKey.use;
            }
            if (this.keyType === KeyType_1.KeyType.RSA) {
                jwkPublic.e = jwkKey.e;
                jwkPublic.n = jwkKey.n;
            }
            else {
                jwkPublic.crv = this._algorithm.namedCurve;
                jwkPublic.x = jwkKey.x;
                jwkPublic.y = jwkKey.y;
            }
            // Save public key
            const keyIdPublic = this.getKeyIdentifier(this.keyType, this.keyUse, KeyExport_1.KeyExport.Public);
            this.cacheJwkKey(keyIdPublic, jwkPublic);
        }
        return jwkKey;
    }
    /**
     * Sign the data with the current key
     * @param data  Data to be signed with the current key
     */
    async sign(data) {
        const keyExport = this.isKeyPair ? KeyExport_1.KeyExport.Private : KeyExport_1.KeyExport.Secret;
        let jwk = await this.getJwkKey(keyExport);
        jwk = DidKey.normalizeJwk(jwk);
        const operations = [KeyOperation_1.KeyOperation.Sign];
        jwk.key_ops = operations;
        if (!jwk.alg) {
            jwk = this.getJoseAlg(this._algorithm, jwk);
        }
        const alg = DidKey.normalizeAlgorithm(this._algorithm);
        const keyObject = await this._crypto.subtle.importKey('jwk', jwk, alg, this._exportable, operations);
        const signature = await this._crypto.subtle.sign(alg, keyObject, data);
        return signature;
    }
    /**
     * Sign the data with the current key
     * @param data  The data signed with the current key
     * @param signature  The signature on the data
     */
    async verify(data, signature) {
        // console.log(`Verify data: ${base64url(data)}`);
        const keyExport = this.isKeyPair ? KeyExport_1.KeyExport.Public : KeyExport_1.KeyExport.Secret;
        let jwk = await this.getJwkKey(keyExport);
        jwk = DidKey.normalizeJwk(jwk);
        const operations = [KeyOperation_1.KeyOperation.Verify];
        jwk.key_ops = operations;
        const alg = DidKey.normalizeAlgorithm(this._algorithm);
        const keyObject = await this._crypto.subtle.importKey('jwk', jwk, alg, this._exportable, operations);
        const success = await this._crypto.subtle.verify(alg, keyObject, signature, data);
        return success;
    }
    /**
     * Generate a pairwise key
     * @param seed  The master seed for generating pairwise keys
     * @param did  The owner DID
     * @param peerId  The representation of the peer
     */
    async generatePairwise(seed, did, peerId) {
        let pairwiseDidKey;
        const didMasterKey = await this.generateDidMasterKey(seed, did);
        const pairwise = this._didPairwiseKeys.get(this.mapDidPairwiseKeys(did, peerId));
        if (pairwise) {
            return pairwise;
        }
        switch (this._keyType) {
            case KeyType_1.KeyType.EC:
            case KeyType_1.KeyType.RSA:
                // Generate new pairwise key
                const pairwiseKey = new PairwiseKey_1.default(did, peerId);
                pairwiseDidKey = await pairwiseKey.generate(didMasterKey.key, this._crypto, this._algorithm, this._keyType, this._keyUse, this._exportable);
                // Cache pairwise key
                this._didPairwiseKeys.set(this.mapDidPairwiseKeys(did, peerId), pairwiseDidKey);
                break;
            default:
                throw new Error(`Pairwise key for type '${this._keyType}' is not supported.`);
        }
        // Store private and public key.
        await pairwiseDidKey.getJwkKey(KeyExport_1.KeyExport.Private);
        return pairwiseDidKey;
    }
    /**
     * Normalize the algorithm so it can be used by underlying crypto.
     * @param algorithm Algorithm to be normalized
     */
    static normalizeAlgorithm(algorithm) {
        if (algorithm.namedCurve) {
            if (algorithm.namedCurve === CURVE_P256K) {
                const alg = clone(algorithm);
                alg.namedCurve = CURVE_K256;
                return alg;
            }
        }
        return algorithm;
    }
    /**
     * Normalize the jwk so it can be used by underlying crypto.
     * @param jwk Json web key to be normalized
     */
    static normalizeJwk(jwk) {
        if (jwk.crv) {
            if (jwk.crv === CURVE_P256K) {
                const key = clone(jwk);
                key.crv = CURVE_K256;
                return key;
            }
        }
        return jwk;
    }
    /**
     * Returns an array of key operations.
     */
    getKeyOperations(keyUse, keyExport) {
        switch (keyUse) {
            case KeyUse_1.KeyUse.Encryption:
                if (this.isKeyPair) {
                    return [KeyOperation_1.KeyOperation.DeriveKey, KeyOperation_1.KeyOperation.DeriveBits];
                }
                return [KeyOperation_1.KeyOperation.Encrypt, KeyOperation_1.KeyOperation.Decrypt];
            case KeyUse_1.KeyUse.Signature:
                if (keyExport === KeyExport_1.KeyExport.Secret || keyExport === KeyExport_1.KeyExport.Private) {
                    return [KeyOperation_1.KeyOperation.Sign];
                }
                else {
                    return [KeyOperation_1.KeyOperation.Verify];
                }
        }
    }
    /**
     * Returns a boolean indicating whether the key
     * type of the instance is either KeyType.EC or
     * KeyType.RSA.
     */
    get isKeyPair() {
        return this._keyType === KeyType_1.KeyType.EC || this._keyType === KeyType_1.KeyType.RSA;
    }
    // Generate a unique key id for storage of pairwise keys
    mapDidPairwiseKeys(did, peerId) {
        // TODO add key use if we want different keys for signing and encryption
        return `${this._keyType}_${did}_${peerId}`;
    }
    /**
     * Generate a pairwise did master key.
     * @param seed  The master seed for generating pairwise keys
     * @param did  The owner DID
     * @param peerId  The representation of the peer
     */
    async generateDidMasterKey(seed, did) {
        let mk = undefined;
        // Check if key was already generated
        this._didMasterKeys.forEach((masterKey) => {
            if (masterKey.did === did) {
                mk = masterKey;
                return;
            }
        });
        if (mk) {
            return mk;
        }
        const alg = { name: 'hmac', hash: 'SHA-512' };
        const signKey = new DidKey(this._crypto, alg, seed);
        await signKey.getJwkKey(KeyExport_1.KeyExport.Secret);
        const signature = await signKey.sign(Buffer.from(did));
        mk = new MasterKey_1.default(did, Buffer.from(signature));
        this._didMasterKeys.push(mk);
        return mk;
    }
    getKeyIdentifier(keyType, keyUse, keyExport) {
        return `${keyType}-${keyUse}-${keyExport}`;
    }
    getJwkKeyFromCache(keyId) {
        // TODO add decryption with a system key
        return this._jwkKeys.get(keyId);
    }
    cacheJwkKey(keyId, jwk) {
        // TODO add encryption with a system key
        this._jwkKeys.set(keyId, jwk);
        return true;
    }
    // Get the key or generate the key if needed
    // Return a keyObject
    async getOrGenerateKey(keyExport) {
        if (this._rawKey === null) {
            // indicate key is generated and raw key was not set by caller
            this._rawKey = undefined;
            // key generation required
            switch (this.keyType) {
                case KeyType_1.KeyType.EC:
                case KeyType_1.KeyType.RSA:
                    return this.generateKeyPair(keyExport);
                case KeyType_1.KeyType.Oct:
                    return this.generateOctKey();
                default:
                    throw new Error(`Key type '${this.keyType}' not supported`);
            }
        }
        else
            return this.setFromRawKey(this._rawKey, keyExport);
    }
    // Generate KeyObject from raw key
    async setFromRawKey(key, keyExport) {
        if (!key) {
            throw new Error('Key must be defined');
        }
        let jwkKey = {};
        if (!key.kty) {
            jwkKey = {
                kty: 'oct',
                kid: TEMPORARY_KID,
                use: this.keyUse,
                k: base64url_1.default(key)
            };
        }
        else {
            if (!key.kid) {
                key.kid = TEMPORARY_KID;
            }
            jwkKey = key;
        }
        // cache the key
        const keyId = this.getKeyIdentifier(this.keyType, this.keyUse, keyExport);
        this.cacheJwkKey(keyId, jwkKey);
        return jwkKey;
    }
    // Generate an oct key and return a jwk key object
    async generateOctKey() {
        const keyObject = await this._crypto.subtle.generateKey(DidKey.normalizeAlgorithm(this._algorithm), this._exportable, this.getKeyOperations(this.keyUse, KeyExport_1.KeyExport.Secret));
        const jwk = await this.keyObjectToJwk(keyObject, KeyExport_1.KeyExport.Secret);
        return jwk;
    }
    // Generate a key pair and return a key object
    async generateKeyPair(keyExport) {
        const alg = DidKey.normalizeAlgorithm(this._algorithm);
        const operations = this.getKeyOperations(this.keyUse, keyExport);
        const keyObject = await this._crypto.subtle.generateKey(alg, this._exportable, operations);
        const jwk = await this.keyObjectToJwk(keyObject, keyExport);
        return jwk;
    }
    async keyObjectToJwk(keyObject, keyExport) {
        let key = {};
        if (keyExport === KeyExport_1.KeyExport.Public) {
            key = keyObject.publicKey;
        }
        else if (keyExport === KeyExport_1.KeyExport.Private) {
            key = keyObject.privateKey;
        }
        else if (keyExport === KeyExport_1.KeyExport.Secret) {
            key = keyObject;
        }
        const jwk = await this._crypto.subtle.exportKey('jwk', key);
        if (!jwk.kid) {
            jwk.kid = TEMPORARY_KID;
        }
        if (jwk.kty === 'octet') {
            jwk.kty = 'oct';
        }
        return jwk;
    }
    /**
     * Map the W3C algorithm to JWA format
     * @param alg Ma
     */
    getJoseAlg(alg, jwk) {
        switch (alg.name.toLowerCase()) {
            case 'hmac':
                switch (alg.hash.toLowerCase()) {
                    case 'sha-256':
                        jwk.alg = 'hs256';
                        return jwk;
                    case 'sha-512':
                        jwk.alg = 'hs512';
                        return jwk;
                }
                break;
            case 'rsassa-pkcs1-v1_5':
                switch (alg.hash.toLowerCase()) {
                    case 'sha-256':
                        jwk.alg = 'RS256';
                        return jwk;
                    case 'sha-512':
                        jwk.alg = 'RS512';
                        return jwk;
                }
                break;
            case 'ecdsa':
                return jwk;
        }
        throw new Error(`Algoritm ${JSON.stringify(alg)} is not supported`);
    }
}
exports.default = DidKey;
//# sourceMappingURL=DidKey.js.map